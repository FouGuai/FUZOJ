# 判题服务模块详细设计

## 1. 目标与原则
- 目标：在超大流量下保持低延迟与高可用；比赛提交优先保障秒级反馈。
- 原则：异步化、分级队列、动态负载均衡、强隔离、安全沙箱、可观测性优先。

## 2. 总体架构
- **Gateway**：鉴权、限流、黑名单、基础校验、快速失败。
- **Judge Dispatcher**：接收提交并写入 Kafka；负责任务分级、分区策略、节流与背压。
- **Judge Service**（多实例）：每个实例管理本地 Worker Pool，按负载从 Kafka 拉取任务。
- **Judge Worker**：沙箱执行器，完成编译、运行、SPJ、交互题。
- **Result Service**：结果汇聚、持久化、回调、榜单更新。
- **存储**：MySQL（提交/结果/配置）、Redis（缓存/状态机）、MinIO（数据/日志/产物）。

## 3. 服务发现与弹性扩缩
- **服务发现**：Judge Service 必须自动注册与发现，支持实例上下线的实时感知。
- **扩缩容策略**：
  - 扩容触发：Kafka lag、P99 判题延迟、实例 CPU/内存超阈值。
  - 缩容触发：低峰期负载下降，保证最小可用实例数。
- **实例负载上报**：定期上报 `cpu/mem/qps/queueDepth` 供调度与运维使用。

## 4. Kafka 任务模型
### 4.1 主题与分区
- 主题按优先级分层：
  - `judge.level0`（比赛提交）
  - `judge.level1`（普通练习）
  - `judge.level2`（自测）
  - `judge.level3`（重判）
- 分区键建议：`contestId` 或 `problemId`，避免热点集中到单实例。
- 每个主题独立分区数，比赛主题优先更高分区数与更多消费者。

### 4.2 消费策略
- **拉取模式**：Judge Service 作为 consumer group，按负载动态拉取。
- **动态权重**：实例通过心跳上报 `cpu/mem/qps/queueDepth`，Dispatcher 或实例侧本地限速。
- **优先级策略**：高优先级主题独立消费；低优先级仅在资源空闲时处理。

### 4.3 任务语义
- 至少一次语义；任务必须幂等。
- 超时与重试：超时后投递到重试主题；超过阈值进入死信队列。

## 5. Judge Service 与 Worker Pool
### 5.1 组件划分
- **Consumer**：从 Kafka 拉取任务。
- **Scheduler**：任务调度器，基于本地负载与资源池进行分配。
- **Worker Pool**：
  - 编译池（Compile Pool）
  - 运行池（Run Pool）
  - SPJ/交互池（Validator/Interactor Pool）

### 5.2 资源与背压
- 每个池都有独立并发上限与排队上限。
- 触顶时对低优先级任务做延迟或拒绝策略。
- 支持本地排队时间上限（避免长尾）。
- 单机部署场景下，采用 Service 层并发限制；池满时将任务重投递到 `judge.retry`，并带指数退避与最大重投递次数，超限进入死信队列。

## 6. 判题执行与安全沙箱
- 采用 cgroups + namespace + seccomp 白名单。
- 资源限制：CPU 时间、Wall Time、内存、栈、输出大小、进程数。
- 禁止网络访问与非标准输入输出文件访问。
- 支持任务取消与中止，超时或撤回立即回收资源。
- 支持 **killTask**：可按 `submissionId` 强制终止运行中的进程树并释放资源。

## 7. 缓存与数据访问
- 题目配置、测试数据索引、SPJ/交互器二进制、编译器镜像层：
  - 本地内存缓存 → Redis → MinIO/DB。
- 热点题目/比赛独立缓存与预热。
- 读：`cache.GetWithCached()`；空值缓存短 TTL 防穿透。
- 编译产物与依赖缓存，复用相同代码与参数的编译结果以降低峰值负载。
- 本地缓存必须有回收机制：容量上限 + LRU/TTL 淘汰，后台定期清理，避免无界增长与抖动。

## 8. 题目数据与测试用例管理
### 8.1 存储模型
- **对象存储**：MinIO 存测试数据包与大文件（每题 `data.zip` 或分片包）。  
- **元数据**：MySQL 存题目配置、测试点分组、分值、哈希与版本。  
- **索引清单**：生成 `manifest.json` 描述测试点列表、大小、md5、分组、分值。  
- **本地缓存**：Worker 首次拉取后解压到本地缓存目录，后续直接本地读取。  

### 8.2 测试用例制作
- **手动上传**：上传 `.zip`，服务端校验结构与 md5，生成 `manifest.json` 后入库。  
- **Polygon 自动生成**：提供 `generator/validator`，后台异步批量生成并校验，再打包上传。  

### 8.3 SPJ（Special Judge）
- 推荐 Testlib 协议：上传 `checker` 源码并编译成二进制。  
- 判题时在沙箱内执行 SPJ，输入为 `input/output/answer`，输出判定结果。  
- SPJ 二进制本地缓存，避免频繁编译。  

## 9. 大流量保护机制
- **入口限流**：按用户/IP/比赛/题目维度限流。
- **队列削峰**：Kafka 作为削峰；低优先级延迟消费。
- **熔断与降级**：实例负载过高时只消费高优先级主题。
- **背压**：实例侧本地队列限流，避免消费者堆积。
- **热点隔离**：热门比赛/题目使用独立主题或分区。

## 10. 判题状态机
- Pending → Compiling(可选) → Running → Judging → Finished/Failed
- 失败类型：编译失败、运行失败、系统错误。
- 系统错误自动重判，超过阈值报警。
- 结果持久化成功后再提交 Kafka offset，避免重复计分或丢失。
- 判题结果支持测试点明细与子任务得分。

## 11. 可观测性
- 关键指标：
  - Kafka lag、主题吞吐
  - 判题 P95/P99 延迟
  - Worker 负载、队列深度
  - 编译/运行耗时拆分与失败率（按语言/题目/比赛维度）
  - 排队等待时间与任务取消率
  - 缓存命中率
- Tracing：全链路追踪提交到结果。

## 12. 关键配置建议
- 主题分区数与 consumer 数量按比赛规模动态调整。
- Worker 池大小与机器资源绑定，默认 CPU 核数 * 2。
- 低优先级任务设置最大排队时长，避免无界堆积。
- 按语言/任务类型设定独立并发与配额，避免长编译挤占运行资源。
- 日志与错误输出设置上限，避免日志膨胀。

## 13. 结果通知与数据返回（最优方案）
- 判题完成后由 Result Service **先落库**，再发布事件到 Kafka（如 `judge.result`）。  
- 上层业务服务订阅事件并处理：  
  - Submit/Contest Service：更新榜单、统计、罚时。  
  - Notification Service：WebSocket/站内信推送给前端。  
- 前端获取结果以推送为主，`GET /submissions/{id}` 作为断线兜底查询。  
- 事件必须携带 `submissionId` 与最终判题结果，保证消费幂等。  

## 14. 后续落地检查清单
- Kafka 主题与分区规划完成
- Judge Service 心跳与负载上报落地
- 服务发现与自动扩缩策略落地
- Worker 池并发与背压策略实现
- 任务取消与重试策略落地
- 编译缓存与测试数据预热策略落地
- 监控与报警规则配置

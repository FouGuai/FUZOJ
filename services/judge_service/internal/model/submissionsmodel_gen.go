// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package model

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
)

type (
	submissionsModel interface {
		FindFinalStatus(ctx context.Context, submissionID string) (string, error)
		FindFinalStatusBatch(ctx context.Context, submissionIDs []string) ([]SubmissionFinalStatus, error)
		UpdateFinalStatus(ctx context.Context, submissionID string, payload string, finishedAt time.Time) (sql.Result, error)
	}

	defaultSubmissionsModel struct {
		sqlc.CachedConn
		table string
	}
)

func newSubmissionsModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultSubmissionsModel {
	return &defaultSubmissionsModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`submissions`",
	}
}

func (m *defaultSubmissionsModel) FindFinalStatus(ctx context.Context, submissionID string) (string, error) {
	query := fmt.Sprintf("select `final_status` from %s where `submission_id` = ? and `final_status` is not null limit 1", m.table)
	var resp struct {
		FinalStatus string `db:"final_status"`
	}
	if err := m.QueryRowNoCacheCtx(ctx, &resp, query, submissionID); err != nil {
		if errors.Is(err, sqlx.ErrNotFound) {
			return "", ErrNotFound
		}
		return "", err
	}
	return resp.FinalStatus, nil
}

func (m *defaultSubmissionsModel) FindFinalStatusBatch(ctx context.Context, submissionIDs []string) ([]SubmissionFinalStatus, error) {
	if len(submissionIDs) == 0 {
		return nil, nil
	}
	placeholders := make([]string, 0, len(submissionIDs))
	args := make([]any, 0, len(submissionIDs))
	for _, id := range submissionIDs {
		placeholders = append(placeholders, "?")
		args = append(args, id)
	}
	query := fmt.Sprintf(
		"select `submission_id`, `final_status` from %s where `submission_id` in (%s) and `final_status` is not null",
		m.table,
		strings.Join(placeholders, ","),
	)
	var resp []SubmissionFinalStatus
	if err := m.QueryRowsNoCacheCtx(ctx, &resp, query, args...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *defaultSubmissionsModel) UpdateFinalStatus(ctx context.Context, submissionID string, payload string, finishedAt time.Time) (sql.Result, error) {
	query := fmt.Sprintf("update %s set `final_status` = ?, `final_status_at` = ? where `submission_id` = ?", m.table)
	return m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (sql.Result, error) {
		return conn.ExecCtx(ctx, query, payload, finishedAt, submissionID)
	})
}
